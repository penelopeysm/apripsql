module Utils
  ( toCsv,
    fromCsv,
    WithId (..),
    toIdCsv,
    fromIdCsvWithId,
    fromIdCsvWithoutId,
    readInt,
    readMaybeInt,
    bsToString,
  )
where

import qualified Data.ByteString as B
import qualified Data.ByteString.Lazy as BL
import qualified Data.Csv as Csv
import Data.HashMap.Strict (union)
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import qualified Data.Text.IO as T
import Data.Text.Read (decimal)
import qualified Data.Vector as V

toCsv :: (Csv.ToNamedRecord a, Csv.DefaultOrdered a) => FilePath -> [a] -> IO ()
toCsv fname = BL.writeFile fname . Csv.encodeDefaultOrderedByName

fromCsv :: (Csv.FromNamedRecord a) => FilePath -> IO [a]
fromCsv fname = do
  csvData <- BL.readFile fname
  case Csv.decodeByName csvData of
    Left err -> error err
    Right (_, v) -> pure $ V.toList v

-- | A wrapper around a value that also stores a numeric ID.
data WithId a = WithId {id' :: Int, value :: a}
  deriving (Eq, Ord, Show)

instance (Csv.ToNamedRecord a) => Csv.ToNamedRecord (WithId a) where
  toNamedRecord (WithId id' a) =
    Csv.namedRecord [("id", Csv.toField id')] `union` Csv.toNamedRecord a

instance (Csv.FromNamedRecord a) => Csv.FromNamedRecord (WithId a) where
  parseNamedRecord m = do
    id' <- m Csv..: "id"
    a <- Csv.parseNamedRecord m
    pure $ WithId id' a

instance (Csv.DefaultOrdered a) => Csv.DefaultOrdered (WithId a) where
  headerOrder _ = V.cons "id" (Csv.headerOrder (undefined :: a))

-- | Write a list of values to a CSV file, with each value having an
-- autogenerated ID (starting from 1)
toIdCsv :: (Show a, Csv.ToNamedRecord a, Csv.DefaultOrdered a) => FilePath -> [a] -> IO ()
toIdCsv fname values = toCsv fname $ zipWith WithId [1 ..] values

-- | Read a list of values from a CSV file. The CSV file is assumed to have an
-- 'id' column. The data are returned with the IDs (wrapped in the WithId type).
fromIdCsvWithId :: (Csv.FromNamedRecord a) => FilePath -> IO [WithId a]
fromIdCsvWithId fname = do
  csvData <- BL.readFile fname
  case Csv.decodeByName csvData of
    Left err -> error err
    Right (_, v) -> pure $ V.toList v

-- | Read a list of values from a CSV file. The CSV file is assumed to have an
-- 'id' column. The data are returned without the IDs.
fromIdCsvWithoutId :: (Csv.FromNamedRecord a) => FilePath -> IO [a]
fromIdCsvWithoutId fname = do
  withIds <- fromIdCsvWithId fname
  pure $ map value withIds

-- | Converts a Text to an Int, throwing an error if it fails.
readInt :: Text -> Int
readInt s = fst . fromRightPartial . decimal $ s
  where
    fromRightPartial (Right b) = b
    fromRightPartial (Left _) = error $ T.unpack $ "fromRightPartial: Left when decoding " <> s

readMaybeInt :: Text -> Maybe Int
readMaybeInt s = case decimal s of
  Right (i, _) -> Just i
  Left _ -> Nothing

bsToString :: B.ByteString -> String
bsToString = T.unpack . TE.decodeUtf8
